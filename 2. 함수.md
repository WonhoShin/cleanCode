# 함수
아래의 코드를 읽어보라

![img.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg.png)
![img_2.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg_2.png)

(img, img_2)

아마도 읽기 힘들 것이다. 추상화 수준도 너무 다양하고 코드도 너무 길다.

두 겹으로 중첩된 if문의 이상한 플래그를 확인하고, 이상한 문자열을 사용해서, 이상한 함수를 호출한다.

이를 아래로 리팩토링 해본다.

![img_1.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg_1.png)

(img_1)

어째서 아래 코드가 읽기 더 편하고 또 읽는 사람이 이를 직관적으로 파악할 수 있을까?

## 작게 만들어라!
함수를 만드는 첫째 규칙은 **작게** 만드는 것이다. 

무조건 짧게라는 말은 없고 책에서는 근거도 제시하지 않았지만 img_1보다 짧아야 한다고 했다.
또한 img_1은 img_3 으로 줄여야 마땅하다고 했다.


![img_3.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg_3.png)

(img_3)

### 불록과 들여쓰기
다시 말해, if문과 case 등에 들어가는 블록은 한 줄이어야 한다는 의미이다. 대게 거기서 함수를 호출하는 형태로 만들어야 한다.

이렇게 하면 바깥을 감싸는 함수가 작아지고, 코드를 이해하기 쉬워진다. (적절한 이름을 붙인다면)
중요한 내용은 중첩 구조가 생길만큼 한수가 커지면 안되나느 뜻이다.

### 한 가지만 해라!
img_1은 여러 가지를 처리한다. 버퍼를 생성하고, 페이지를 가져오고, 상속된 페이지를 검색하고, 경로를 랜더링하고, 불가사의한 문자열으 덧붙이고, html을 생성한다.

**"한수는 한 가지를 해야 한다. 그 한가지를 잘해야 하고 그 한가지만 해야한다."**

위 충고의 문제점은 한가지가 무엇인지 알기 힘들다는 것이다. 과연 img_3은 한 가지만 하는가? 세 가지를 한다고 주장할 수도 있다.
1. 페이지가 테스트 페이지 인지 판단한다.
2. 그렇다면 설정 페이지오 ㅏ함께 해제 페이지를 넣는다.
3. 페이지를 HTML로 랜더링한다.

위에서 언급하는 세 단계는 지정된 함수 이름 아래에서 추상화 수준이 하나이다.
위 함수는 간단한 문단으로 기술할 수 있다.

~~~
페이지가 테스트 페이지인지 확인 한 후 테스트 페이지라면 설정 페이지와 함께 해제페이지를 넣는다. 테스트 페이지든 아니든 페이지를 HTML로 렌더링한다.
~~~

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 한다.
이는... 정의된 내용이 있다면 그 내용을 충실히 단계로 나눠서 하라는 의미 같다.

단순하게 명쾌한 답을 주자면 함수가 '한가지만' 하는지 판별하려면, 해당 함수 내용에서 의미있는 이름으로 작업을 분리할 수 있다면 

그 함수는 여러 가지 일을 한다고 할 수 있다.

### 함수 당 추상화 수준은 하나로 하라
함수가 확실하게 한 가지 일을 하게 하려면 함수 내 문장이 모두 같은 추상화 수준을 가져야 한다. 이게 무슨 말일까... img,img_2는 여러 가지 추상화 수준을 가진 코드이다.
예를 들어, getHtml은 아주 높은 수준의 추상화이고, PagePathName = PathParser.render(pagePath)는 중간 수준, .append()는 아주 낮은 수준의 추상화를 갖는다.

추상화 수준이 섞여있으면 읽는 사람이 헷갈린다. 정확하게는 특정 표현(함수 내 코드)가 근본 개념인지 세부사항인지 모르기 때문에 수정할 때 세부사항이 점점 추가 된다.
(근본 개념, 세부사항이라면 다른 함수의 호출부인지, 아니면 직접적인 로직에 대한 코드인 정도로 이해했다.)

### 위에서 아래로 코드 읽기 : 내려가기 규칙
코드는 위에서 아래로 이야기 처럼 읽혀야 좋다. 한 함수에서 다음 추상화 수준이 낮은 함수를 호출해야 한다. 이렇게 짜기는 힘든데 이것이 내려가기 규칙이고 이렇게 짜야 한다.

### switch 문은 작게 만들기 어렵다.
switch 문은 작게 만들기 어렵다. case 분기에 따라서 n가지 일을 처리하기 때문이다. 하지만 각 switch 문을 저차원의 클래스에 숨기고 반복하지 않는 방법이 있다.

(다형성을 사용한다.)

파일4는 직원 유형에 따라 다른 값을 반환하는 함수다.

![img_4.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg_4.png)

(4)

위 코드의 문제점은 첫째, 길이가 길다. 새 직원을 추가하면 더 길어진다. 둘째, '한 가지' 작업만 수행하지 않는다. 셋째, SRP를 위배한다. 코드 변경의 이유가 많기 

떄문이다. 넷째, OCP를 위반한다. 새로운 유형의 직원이 추가될 때마다 코드가 변경되기 때문이다. 가장 심각한 문제는 위 함수와 동일한 구조의 함수가 무한정 존재한다는

것이다. (그렇게 짰으면) 위 코드를 해결한 코드가 (5) 이다. 5는 switch 문을 추상 팩토리에 숨긴다.

![img_5.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg_5.png)

(5)

내 생각 : 

switch 문에 대한 변경은 이해가 잘 가지 않는다. 직원 추상클래스를 만들고, 추상메서드를 여럿 선언하여 관련 기능을 모은 것 같다. 클래스에 구현이 여럿이 아닌 개별 

구체화된 클래스에서 이뤄지므로 변화가 있을 때 기존 코드가 변경되지 않는 다는 것은 이해가 간다. 아 이게 전달하려는 것 같다. 이렇게 된다면 근데

유형에 따라 코드는 추가 되고.. 기존 코드는 변경이 없다고 할 수 있을지 모르겠다. 여전히 factoryImpl은 직원 타입이 추가될 때마다 코드에 변화가 있는데 확장이 

맞는지 모르겠다. 아 책에서는 저렇게 한 번 숨긴거 까진 봐준다고 한다. (저자 기준으로) 기존 코드 변경이 없게 하려면

ENUM으로 정의하고 인터페이스를 추가해서 default 메서드를 생성해서 확장에도 변화를 막을 수 있을 것 같다.

그럼 되겠다. (서영민님이 알려준 테크닉, 헷갈리면 다시 물어보기)

### 인수 값을 너무 많이 넣지 말아라
인수에 대해 복잡도가 커지기 때문에 2개까지 ok, 그 이상이면 안된다. 왜냐하면 인수를 발견할 떄 마다 의미를 파악해야 하기 때문이다.

### 많이 쓰는 단항 형식
함수에 인수를 1개 넘기는 이유는 흔히 두 가지 이다. 하나는 인수에 질문을 던지는 경우이다. 예를 들어, ``boolean isMyFile("44")``
이 좋은 예다.

다른 하나는 인수로 뭔가를 변환해 결과를 반환하는 경우이다. 이 때 void를 쓰지말고, 반환값으로 인수와 같은 자료형의 데이터를 반환해야 한다.

이렇게 하지 않으면 사용자에게 혼란을 돌려준다.

### 플래그 인수
플래그 인수를 쓰는 거 자체가 추하다. boolean 을 넘겨서 여러가지 작업을 한다고 대놓고 말하는 격이다.

내 생각 :

이 후에 이항, 삼항 가지고도 말이 있는데 좀 개소리같은 것도 있고... 여기서 하고 싶은 말은 전달하는 인수가 많을 수록 관심영역이 많아져서 복잡도가 

올라간다는 표현같다. 내 경우, 쿠폰 생성 시, 관련 DTO안에 데이터를 세팅하여 하나로 전달한다. 혹은 이항인 경우 주로 사용자아이디인데 같이 포함하던지

허용해줘서 두 개 정도로 유지하던지 해야겠다. 결국 여러 데이터를 인자 하나로 던지려면 통합과정도 필요한데 이 역시 복잡도를 높히는 것으로 봐야할지 혹은 적절한 조치인지

헷갈린다.

### 오류 코드보단 예외를 사용하라
로직 코드 내에 오류에 대한 예외가 if로 들어간 경우에 코드가 복잡해지고 에러 핸들링에 대한 부분과 로직에 대한 부분이 섞인다.

그러므로 오류를 던져 오류를 캐치하여 처리하도록 수정해야 한다.

### try/catch는 추하다
코드 구조에 혼란을 일으키며 정상 동작과 오류 동작을 섞기 때문에 별도로 뽑아내서 사용한다. 아래 예시를 보자

![img_6.png](attachments%2F2.%20%ED%95%A8%EC%88%98%2Fimg_6.png)

(6)













